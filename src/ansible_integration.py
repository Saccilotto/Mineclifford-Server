#!/usr/bin/env python3
"""
Integration script between Version Manager and Ansible.
Generates Ansible-compatible variable files from Version Manager queries.
"""

import asyncio
import argparse
import os
import secrets
import sys
import yaml
from pathlib import Path
from typing import Dict, Any, Optional

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from version_manager.manager import MinecraftVersionManager
from version_manager.base import ServerType


class AnsibleIntegration:
    """Integration between Version Manager and Ansible."""

    def __init__(self):
        self.manager = MinecraftVersionManager()
        self.config: Dict[str, Any] = {}

    async def resolve_version(
        self,
        server_type_str: str,
        version: str = "latest"
    ) -> str:
        """
        Resolve a version string to a concrete version.

        Args:
            server_type_str: Server type (paper, vanilla, etc.)
            version: Version string or "latest"

        Returns:
            Resolved version string
        """
        try:
            server_type = ServerType(server_type_str.lower())
        except ValueError:
            print(f"Error: Invalid server type '{server_type_str}'")
            sys.exit(1)

        if version == "latest":
            version_info = await self.manager.get_latest_version(server_type)
            return version_info.version
        else:
            # Validate the version
            is_valid = await self.manager.validate_version(server_type, version)
            if not is_valid:
                print(f"Warning: Version {version} may not be valid for {server_type_str}")
            return version

    async def get_download_url(
        self,
        server_type_str: str,
        version: str
    ) -> str:
        """
        Get download URL for a version.

        Args:
            server_type_str: Server type
            version: Version string

        Returns:
            Download URL
        """
        try:
            server_type = ServerType(server_type_str.lower())
            return await self.manager.get_download_url(server_type, version)
        except ValueError as e:
            print(f"Error: {e}")
            sys.exit(1)

    async def generate_ansible_vars(
        self,
        java_type: str = "paper",
        java_version: str = "latest",
        java_memory: str = "2G",
        java_gamemode: str = "survival",
        java_difficulty: str = "normal",
        bedrock_enabled: bool = False,
        bedrock_version: str = "latest",
        output_file: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generate Ansible variables file.

        Args:
            java_type: Java server type (paper, vanilla, spigot, etc.)
            java_version: Java server version or "latest"
            java_memory: Memory allocation
            java_gamemode: Game mode
            java_difficulty: Difficulty level
            bedrock_enabled: Whether to enable Bedrock server
            bedrock_version: Bedrock server version
            output_file: Optional output file path

        Returns:
            Dictionary of Ansible variables
        """
        # Resolve Java version
        resolved_java_version = await self.resolve_version(java_type, java_version)
        java_download_url = await self.get_download_url(java_type, resolved_java_version)

        # Build Ansible vars
        vars_dict = {
            "# Minecraft Server Configuration": None,
            "# Generated by Mineclifford Version Manager": None,
            "": None,

            "# Java Edition": None,
            "minecraft_java_type": java_type,
            "minecraft_java_version": resolved_java_version,
            "minecraft_java_download_url": java_download_url,
            "minecraft_java_memory": java_memory,
            "minecraft_java_gamemode": java_gamemode,
            "minecraft_java_difficulty": java_difficulty,
            "minecraft_java_motd": f"Mineclifford {java_type.capitalize()} Server",
            "minecraft_java_allow_nether": True,
            "minecraft_java_enable_command_block": True,
            "minecraft_java_spawn_protection": 0,
            "minecraft_java_view_distance": 10,

            " ": None,
            "# Bedrock Edition": None,
            "minecraft_bedrock_enabled": bedrock_enabled,
        }

        if bedrock_enabled:
            resolved_bedrock_version = await self.resolve_version("vanilla", bedrock_version)
            vars_dict.update({
                "minecraft_bedrock_version": resolved_bedrock_version,
                "minecraft_bedrock_memory": "1G",
                "minecraft_bedrock_gamemode": "survival",
                "minecraft_bedrock_difficulty": "normal",
                "minecraft_bedrock_server_name": "Mineclifford Bedrock Server",
                "minecraft_bedrock_allow_cheats": False,
            })

        vars_dict.update({
            "  ": None,
            "# Monitoring": None,
            "rcon_password": os.getenv('RCON_PASSWORD', secrets.token_urlsafe(16)),
            "grafana_password": os.getenv('GRAFANA_PASSWORD', secrets.token_urlsafe(16)),
            "timezone": "America/Sao_Paulo",

            "   ": None,
            "# Server Configuration": None,
            "server_names": ["instance1"],
            "single_node_swarm": True,
        })

        # Clean up None values (comments)
        clean_vars = {k: v for k, v in vars_dict.items() if v is not None}

        # Output to file if specified
        if output_file:
            output_path = Path(output_file)
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, 'w') as f:
                f.write("---\n")
                yaml.dump(clean_vars, f, default_flow_style=False, sort_keys=False)

            print(f"Ansible variables written to: {output_file}")

        return clean_vars

    async def list_available_versions(self, server_type_str: str, limit: int = 10):
        """
        List available versions for a server type (Ansible-friendly format).

        Args:
            server_type_str: Server type
            limit: Maximum number of versions to show
        """
        try:
            server_type = ServerType(server_type_str.lower())
            versions = await self.manager.list_versions(server_type)

            print(f"Available {server_type_str} versions (showing {limit}):")
            for i, v in enumerate(versions[:limit]):
                print(f"  - {v.version}")

            if len(versions) > limit:
                print(f"  ... and {len(versions) - limit} more")

        except ValueError as e:
            print(f"Error: {e}")
            sys.exit(1)


async def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Ansible integration for Mineclifford Version Manager",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate Ansible vars for latest Paper
  %(prog)s generate --java-type paper --output deployment/ansible/minecraft_vars.yml

  # Generate with specific version
  %(prog)s generate --java-type paper --java-version 1.20.1-196 -o vars.yml

  # List available versions
  %(prog)s list paper

  # Resolve a version
  %(prog)s resolve paper latest
        """
    )

    subparsers = parser.add_subparsers(dest="command", help="Command to execute")

    # Generate command
    gen_parser = subparsers.add_parser("generate", help="Generate Ansible variables")
    gen_parser.add_argument("--java-type", default="paper", help="Java server type")
    gen_parser.add_argument("--java-version", default="latest", help="Java version")
    gen_parser.add_argument("--java-memory", default="2G", help="Java memory")
    gen_parser.add_argument("--java-gamemode", default="survival", help="Game mode")
    gen_parser.add_argument("--java-difficulty", default="normal", help="Difficulty")
    gen_parser.add_argument("--bedrock", action="store_true", help="Enable Bedrock")
    gen_parser.add_argument("--bedrock-version", default="latest", help="Bedrock version")
    gen_parser.add_argument("-o", "--output", help="Output file path")

    # List command
    list_parser = subparsers.add_parser("list", help="List available versions")
    list_parser.add_argument("type", help="Server type")
    list_parser.add_argument("--limit", type=int, default=10, help="Max versions to show")

    # Resolve command
    resolve_parser = subparsers.add_parser("resolve", help="Resolve version string")
    resolve_parser.add_argument("type", help="Server type")
    resolve_parser.add_argument("version", help="Version string or 'latest'")

    # URL command
    url_parser = subparsers.add_parser("url", help="Get download URL")
    url_parser.add_argument("type", help="Server type")
    url_parser.add_argument("version", help="Version string")

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    integration = AnsibleIntegration()

    if args.command == "generate":
        await integration.generate_ansible_vars(
            java_type=args.java_type,
            java_version=args.java_version,
            java_memory=args.java_memory,
            java_gamemode=args.java_gamemode,
            java_difficulty=args.java_difficulty,
            bedrock_enabled=args.bedrock,
            bedrock_version=args.bedrock_version,
            output_file=args.output
        )
    elif args.command == "list":
        await integration.list_available_versions(args.type, args.limit)
    elif args.command == "resolve":
        version = await integration.resolve_version(args.type, args.version)
        print(f"Resolved version: {version}")
    elif args.command == "url":
        url = await integration.get_download_url(args.type, args.version)
        print(f"Download URL: {url}")


if __name__ == "__main__":
    asyncio.run(main())
