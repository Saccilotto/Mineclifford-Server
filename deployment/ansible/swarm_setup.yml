- name: Configure Minecraft Server with Docker Swarm
  hosts: all
  become: yes
  vars:
    manager_node: "{{ groups['instance1'][0] }}"
    ansible_python_interpreter: /usr/bin/python3
    minecraft_java_version: "latest"
    minecraft_java_memory: "2G"
    minecraft_java_gamemode: "survival"
    minecraft_java_difficulty: "normal"
    minecraft_java_motd: "Mineclifford Java Server"
    minecraft_bedrock_version: "latest"
    minecraft_bedrock_memory: "1G"
    minecraft_bedrock_gamemode: "survival"
    minecraft_bedrock_difficulty: "normal"
    rcon_password: "minecraft"
    grafana_password: "admin"
    timezone: "America/Sao_Paulo"
    single_node_swarm: "{{ groups['all'] | length == 1 }}"

  tasks:
  # Docker setup tasks
  - name: Remove old Docker versions
    apt:
      name:
        - docker
        - docker-engine
        - docker.io
        - containerd
        - runc
      state: absent
      update_cache: yes

  - name: Install dependencies
    apt:
      name:
        - curl
        - ca-certificates
        - git
        - acl
        - python3
        - python3-pip
        - lsb-release
        - wget
        - netcat-openbsd
        - dnsutils
        - openjdk-21-jre-headless
      state: present
      update_cache: yes

  # Install monitoring tools
  - name: Install monitoring tools
    apt:
      name:
        - htop
        - iotop
        - sysstat
        - vnstat
      state: present
    become: yes

  - name: Install Docker SDK for Python
    apt:
      name: python3-docker
      state: present
      update_cache: yes
  
  - name: Add Docker's official GPG key
    ansible.builtin.get_url:
      url: https://download.docker.com/linux/ubuntu/gpg
      dest: /tmp/docker.gpg
      mode: '0644'
    become: yes

  - name: Convert GPG key to binary format
    ansible.builtin.command:
      cmd: gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg /tmp/docker.gpg
      creates: /usr/share/keyrings/docker-archive-keyring.gpg
    become: yes

  - name: Add Docker's repository
    ansible.builtin.apt_repository:
      repo: "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
      state: present
      filename: docker
    become: yes

  - name: Update apt cache
    ansible.builtin.apt:
      update_cache: yes

  - name: Install Docker packages
    apt:
      name:
        - docker-ce
        - docker-ce-cli
        - containerd.io
      state: present
      update_cache: yes

  - name: Add users to the Docker group
    user:
      name: "{{ item }}"
      groups: docker
      append: yes
    loop:
      - "{{ ansible_ssh_user }}"
    ignore_errors: yes

  - name: Check if node is already part of a swarm
    community.docker.docker_swarm_info:
    register: swarm_info
    ignore_errors: yes
    
  - name: Initialize Swarm on manager node
    community.docker.docker_swarm:
      state: present
      advertise_addr: "{{ inventory_hostname }}"
    when: inventory_hostname == manager_node and (swarm_info.failed or not swarm_info.docker_swarm_active)
    register: swarm_init
    ignore_errors: yes

  # Multi-node swarm setup
  - name: Get swarm worker token
    community.docker.docker_swarm_info:
    register: swarm_worker_info
    when: inventory_hostname == manager_node and not single_node_swarm and groups['all'] | length > 1

  - name: Set worker token from swarm info
    set_fact:
      token_output: "{{ swarm_worker_info }}"
    when: inventory_hostname == manager_node and not single_node_swarm and groups['all'] | length > 1
    
  - name: Set token fact on manager
    set_fact:
      worker_token: "{{ token_output.swarm_facts.JoinTokens.Worker }}"
    when: inventory_hostname == manager_node and not single_node_swarm and token_output is defined and token_output.swarm_facts is defined
    
  - name: Share token with workers
    set_fact:
      worker_token: "{{ hostvars[groups['instance1'][0]].worker_token }}"
    when: inventory_hostname != manager_node and not single_node_swarm and hostvars[groups['instance1'][0]].worker_token is defined
    
  - name: Join workers to swarm
    community.docker.docker_swarm:
      state: join
      advertise_addr: "{{ inventory_hostname }}"
      join_token: "{{ worker_token }}"
      remote_addrs: ["{{ manager_node }}:2377"]
    when: inventory_hostname != manager_node and not single_node_swarm and worker_token is defined
    ignore_errors: yes
    
  # For single node swarm
  - name: Ensure node is a swarm manager in single-node mode
    community.docker.docker_swarm:
      state: present
      advertise_addr: "{{ inventory_hostname }}"
      force: yes
    when: single_node_swarm and (swarm_info.failed or not swarm_info.docker_swarm_active)
    ignore_errors: yes

  # Get manager node IP
  - name: Get manager node IP
    set_fact:
      manager_ip_result: "{{ ansible_default_ipv4.address }}"
    delegate_to: "{{ manager_node }}"
    run_once: true

  - name: Import Minecraft world if provided
    block:
      - name: Create temporary directory for world import
        file:
          path: /tmp/minecraft-world-import
          state: directory
          mode: '0755'
        when: minecraft_world_import is defined

      # Aternos exports .zip; the ops script converts it to .tar.gz before passing here.
      # The archive must contain the world/ folder at its root (standard Aternos layout).
      - name: Copy world archive to server
        copy:
          src: "{{ minecraft_world_import }}"
          dest: /tmp/minecraft-world-import/world.tar.gz
          mode: '0644'
        when: minecraft_world_import is defined

      # WORLD must point to the file, not the directory — itzg extracts it to /data
      - name: Verify world archive was copied
        stat:
          path: /tmp/minecraft-world-import/world.tar.gz
        register: world_archive_stat
        when: minecraft_world_import is defined

      - name: Fail if world archive is missing
        fail:
          msg: "World archive was not copied to /tmp/minecraft-world-import/world.tar.gz"
        when: minecraft_world_import is defined and not world_archive_stat.stat.exists

  # Create directory for Prometheus config
  - name: Create Prometheus configuration directory
    file:
      path: /home/{{ ansible_ssh_user }}/prometheus
      state: directory
      mode: '0755'
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Copy Prometheus configuration
  - name: Copy Prometheus configuration file
    copy:
      src: ../swarm/prometheus/prometheus.yml
      dest: /home/{{ ansible_ssh_user }}/prometheus/prometheus.yml
      mode: '0644'
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Get manager node IP
  - name: Get manager node IP
    shell: hostname -I | awk '{print $1}'
    register: manager_ip_result
    delegate_to: "{{ manager_node }}"
    run_once: true

  - name: Get manager and worker IPs for stack
    set_fact:
      manager_ip_value: "{{ manager_ip_result }}"
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Create .env file for stack deployment
  - name: Create .env file for stack deployment
    template:
      src: stack.env.j2
      dest: /home/{{ ansible_ssh_user }}/.env
    vars:
      manager_ip: "{{ manager_ip_value }}"
      single_node_swarm: "{{ groups['all'] | length == 1 }}"
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Create traefik network if it doesn't exist
  - name: Create traefik network
    shell: docker network create --driver=overlay traefik_network || true
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Render stack.yml — minecraft_world_import and minecraft_world_import_dir are
  # injected via extra_vars (-e @minecraft_vars.yml) when a world import is requested.
  # The {% if minecraft_world_import is defined %} blocks in stack.yml activate only
  # when those vars are present, so no hardcoded flag is needed here.
  - name: Process stack template
    template:
      src: ../swarm/stack.yml
      dest: /home/{{ ansible_ssh_user }}/stack.yml
    vars:
      manager_ip: "{{ manager_ip_value }}"
      single_node_swarm: "{{ groups['all'] | length == 1 }}"

  # Deploy the stack
  - name: Deploy the Minecraft stack
    shell: docker stack deploy --with-registry-auth -c /home/{{ ansible_ssh_user }}/stack.yml Mineclifford
    args:
      chdir: /home/{{ ansible_ssh_user }}
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Wait for services to start up
  - name: Wait for services to start up (120 seconds)
    pause:
      seconds: 120

  # Check service status
  - name: Check service status
    command: docker service ls
    register: service_status
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Get final status
  - name: Show service status
    community.docker.docker_swarm_service_info:
    delegate_to: "{{ manager_node }}"
    run_once: true
    register: final_service_status
    ignore_errors: yes
  
  - name: Display service status
    debug:
      var: final_service_status.services
    when: final_service_status is defined and final_service_status.services is defined
    
  # Create backup script for Minecraft worlds
  - name: Create backup script for Minecraft worlds
    copy:
      dest: /home/{{ ansible_ssh_user }}/backup-minecraft.sh
      content: |
        #!/bin/bash
        BACKUP_DIR="/home/{{ ansible_ssh_user }}/minecraft-backups"
        DATE=$(date +%Y%m%d_%H%M%S)
        mkdir -p $BACKUP_DIR
        
        # Backup Java world
        echo "Backing up Java Edition world..."
        docker run --rm -v mineclifford_minecraft_java_data:/data -v $BACKUP_DIR:/backup \
          alpine tar -czf /backup/minecraft_java_$DATE.tar.gz -C /data .
        
        # Backup Bedrock world
        echo "Backing up Bedrock Edition world..."
        docker run --rm -v mineclifford_minecraft_bedrock_data:/data -v $BACKUP_DIR:/backup \
          alpine tar -czf /backup/minecraft_bedrock_$DATE.tar.gz -C /data .
        
        # Keep only the last 5 backups
        cd $BACKUP_DIR
        ls -t minecraft_java_*.tar.gz | tail -n +6 | xargs -r rm
        ls -t minecraft_bedrock_*.tar.gz | tail -n +6 | xargs -r rm
        
        echo "Backup completed: $(date)"
      mode: '0755'
    delegate_to: "{{ manager_node }}"
    run_once: true

  # Add cron job for daily backups
  - name: Add cron job for daily Minecraft backups
    cron:
      name: "Minecraft world backups"
      hour: "4"
      minute: "0"
      job: "/home/{{ ansible_ssh_user }}/backup-minecraft.sh > /home/{{ ansible_ssh_user }}/minecraft-backup.log 2>&1"
    delegate_to: "{{ manager_node }}"
    run_once: true